- - - - - - - - - - Documentation - - - - - - - - - -
Documentation : https://www.w3.org/TR/sparql11-query/
List of SPARQL expressions and functions : https://en.wikibooks.org/wiki/SPARQL/Expressions_and_Functions
ARQ query engine : https://jena.apache.org/documentation/query/index.html

- - - - - - - - - - - Execution - - - - - - - - - - -
Execute query using Apache Jena ARQ engine :
> bin/sparql --data=project/data/triples.ttl --query=project/queries/q1.rq
> bin/arq --data=project/data/triples.ttl --query=project/queries/q1.rq

Execute online : https://atomgraph.github.io/SPARQL-Playground/

- - - - - - - - - - - Query types - - - - - - - - - -
SPARQL has four result forms :
    SELECT – Return a table of results.
    CONSTRUCT – Return an RDF graph, based on a template in the query.
    DESCRIBE – Return an RDF graph, based on what the query processor is configured to return.
    ASK – Ask a boolean query.

- - - - - - - - - - - - Query - - - - - - - - - - - -
-----------------------------------------------------
# -> Select all triples

SELECT ?s ?p ?o											# <- SELECT clause to indicate which variable to return in what order
WHERE {													# <- WHERE clause as condition
  ?subject ?predicate ?object .							# <- Triple pattern to match. Ends with '.' (last one is optional)
}

-----------------------------------------------------
# -> Select all subject with a family name of "Smith"

PREFIX vcard: <http://www.w3.org/2006/vcard/ns#>		# <- Prefix declaration for shorter querys

SELECT DISTINCT ?person									# <- DISTINCT to remove duplicates
FROM <rdf graph url or path>							# <- FROM clause : specifies where the triple dataset is (multiple FROM statment will merge all datasets into 1 default graph)
WHERE { ?person vcard:family-name "Smith" . }
ORDER BY ?person										# <- ORDER BY to order results by a variable in particular
OFFSET 2												# <- OFFSET clause : skip a certain number of results
LIMIT 10												# <- LIMIT clause : limit total result number

-----------------------------------------------------
# -> Do not have to repeat : use turtle shortcut syntax
PREFIX vcard: <http://www.w3.org/2006/vcard/ns#>

SELECT *
WHERE {
	?person vcard:family-name ?familyName ;				# <- ';' semi colon for next property name with same subject
			vcard:given-name ?givenName ;
			vcard:language "English" ;
			vcard:locality "Paris" ;
			vcard:nickname "Jay" .						# <- '.' period at the end
}

-----------------------------------------------------
# -> Same query but also returns the given name along the family name

PREFIX vcard: <http://www.w3.org/2006/vcard/ns#>		# <- Sandard for job description

SELECT ?person ?name									# <- Here two variables will be returned
WHERE {
	?person vcard:family-name "Smith" .					# <- First triple pattern
	?person vcard:given-name ?name .					# <- Second pattern applied on the result of the first one
}
ORDER BY DESC(?person)									# <- Descending ordering (default is ASC())

-----------------------------------------------------
# -> Filter triples with FILTER clause

PREFIX vcard: <http://www.w3.org/2006/vcard/ns#>
PREFIX sn: <http://www.snee.com/hr/>					# <- Namespace of a specific company

SELECT ?givenName ?familyName ?hiredDate				# <- Here, the 'person' variable is not returned
WHERE {
	?person vcard:family-name ?familyName .
	?person vcard:given-name ?givenName .
	?person sn:hd ?hiredDate .
	FILTER(?hiredDate < "2020-01-01")					# <- FILTER clause to narrow results
}

-----------------------------------------------------
# -> Arithmetic expressions
PREFIX info: <http://somewhere/peopleInfo#>

SELECT ?resource
WHERE {
    ?resource info:age ?age .
    FILTER (?age >= 24)									# <- The arithmetic expression must be in parentheses
}

-----------------------------------------------------
# -> Operator || &&
PREFIX info: <http://somewhere/peopleInfo#>

SELECT ?resource
WHERE {
    ?resource info:age ?age .
    FILTER (?age >= 24 || ?age = 19)					# <- OR operator
}

-----------------------------------------------------
# -> MIN() / MAX() / SUM() / AVG()
PREFIX info: <http://somewhere/peopleInfo#>

SELECT (MAX(?age) AS ?ageMax)							# <- MAX() to get maximum value and (... AS ...) to rename
WHERE { ?resource info:age ?age . }

identical as :

SELECT ?age
WHERE { ?ressource info:age ?age . }
ORDER BY DESC(?age)
LIMIT 1

-----------------------------------------------------
# -> COUNT()
PREFIX info: <http://somewhere/peopleInfo#>

SELECT COUNT(*)											# <- COUNT() to count occurences
WHERE { ?resource info:age 24 . }

-----------------------------------------------------
# -> Make triples optional with the OPTIONAL clause

PREFIX vcard: <http://www.w3.org/2006/vcard/ns#>
PREFIX sn: <http://www.snee.com/hr/>

SELECT ?givenName ?familyName ?orientDate
WHERE {
	?person vcard:family-name ?familyName .
	?person vcard:given-name ?givenName .
	OPTIONAL {											# <- OPTIONAL clause to add more information if the triple is available
		?person sn:completedOrientation ?orientDate .	# <- If matches, returns it, else it will be an empty value
	}
}

-----------------------------------------------------
# -> OPTIONAL + FILTER

PREFIX info:        <http://somewhere/peopleInfo#>
PREFIX vcard:      <http://www.w3.org/2001/vcard-rdf/3.0#>

SELECT ?name ?age
WHERE {
    ?person vcard:FN ?name .
    OPTIONAL {
		?person info:age ?age .							# <- returns the age only if it is available and less than 24
		FILTER (?age < 24)								# <- FILTER inside the OPTIONAL clause : so the filter is also optional !
	}
}

-----------------------------------------------------
# -> Searching for empty values

PREFIX vcard: <http://www.w3.org/2006/vcard/ns#>
PREFIX sn: <http://www.snee.com/hr/>

SELECT ?givenName ?familyName
WHERE {
	?p vcard:family-name ?familyName .
	?p vcard:given-name ?givenName .
	NOT EXISTS { ?p sn:completedOrientation ?oDate . }	# <- NOT EXISTS clause : triple must not match
}

# identical as this query, using bound() and negation operator '!' :

SELECT ?givenName ?familyName
WHERE {
	?p vcard:family-name ?familyName .
	?p vcard:given-name ?givenName .
	OPTIONAL { ?p sn:completedOrientation ?oDate . }
	FILTER (!bound(?Date))								# <- Here, filter checks if ?oDate is NOT bound with a value
}

# identical as this query, using MINUS :

SELECT ?givenName ?familyName
WHERE {
	?p vcard:family-name ?familyName .
	?p vcard:given-name ?givenName .
	MINUS { ?p sn:completedOrientation ?oDate . }		# <- MINUS clause : remove everything that matches these triples
}

-----------------------------------------------------
# -> Create and return a new variable with BIND

PREFIX vcard: <http://www.w3.org/2006/vcard/ns#>

SELECT ?gName ?fName ?fullName							# <- The 'fullName' variable isn't matching any triple, it will be created
WHERE {
	?person vcard:family-name ?fName .
	?person vcard:given-name ?gName .
	BIND(concat(?gName, " ", ?fName) AS ?fullName)		# <- Binds the result of concat() function to the 'fullName' variable
}

-----------------------------------------------------
# -> Create new triples with the CONSTRUCT clause

PREFIX vcard: <http://www.w3.org/2006/vcard/ns#>

CONSTRUCT {												# <- Generates new triples based on the result
	?person vcard:fn ?fullName .
}
WHERE {
	?person vcard:family-name ?fName .
	?person vcard:given-name ?gName .
	BIND(concat(?gName, " ", ?fName) AS ?fullName)
}

-----------------------------------------------------
# -> Use regex to filter strings

PREFIX vcard: <http://www.w3.org/2001/vcard-rdf/3.0#>

SELECT ?name
WHERE {
	?s vcard:Given ?name .
	FILTER regex(?name, "r", "i")						# <- Returns names with the letter 'r' in it (case insensitive)
}
-----------------------------------------------------
# -> UNION to regroup results

PREFIX foaf: <http://xmlns.com/foaf/0.1/>
PREFIX vCard: <http://www.w3.org/2001/vcard-rdf/3.0#>

SELECT ?name
WHERE {
   { [] foaf:name ?name }
   UNION												# <- UNION will regroup all results of each triple pattern as two indpendant queries
   { [] vCard:FN ?name }
}

# faster than this FILTER clause, but identical :

SELECT ?name
WHERE
{
  [] ?p ?name											# <- [] is a blank node
  FILTER ( ?p = foaf:name || ?p = vCard:FN )			# <- || is the OR operator
}
-----------------------------------------------------
# -> GROUP BY to return sub groups of results

PREFIX info:        <http://somewhere/peopleInfo#>
PREFIX vcard:      <http://www.w3.org/2001/vcard-rdf/3.0#>

SELECT ?name											# <- Will return a list of names grouped by age, if age is over 50.
WHERE {
    ?person vcard:FN ?name .
	?person info:age ?age .
}
GROUP BY ?age											# <- Will group results by age
HAVING (?age > 50)										# <- HAVING clause is like a FILTER but for groups

-----------------------------------------------------
# -> Nested subqueries : This calculates the population of each country in the world,
# expressing the population as a percentage of the world's total population

SELECT ?countryLabel ?pop (round(?pop/?worldpop*1000)/10 AS ?percent)
WHERE {
	?country wdt:P31 wd:Q3624078;    # is a sovereign state
        	 wdt:P1082 ?pop.

	{
		# subquery to determine ?worldpop
		SELECT (sum(?pop) AS ?worldpop)
		WHERE {
		?country wdt:P31 wd:Q3624078;    # is a sovereign state
				 wdt:P1082 ?pop.
		}
	}

	SERVICE wikibase:label {bd:serviceParam wikibase:language "[AUTO_LANGUAGE],en".}	# <- This will auto assign ?countryLabel with rdfs:label value for ?country
}
ORDER BY desc(?pop)

-----------------------------------------------------
# -> Named graphs

PREFIX xsd: <http://www.w3.org/2001/XMLSchema#>
PREFIX dc:  <http://purl.org/dc/elements/1.1/>
PREFIX :    <.>											# <- Empty prefix for current directory

SELECT *
FROM       <ds-dft.ttl>									# <- The default graph
FROM NAMED <ds-ng-1.ttl>								# <- Naming a graph
FROM NAMED <ds-ng-2.ttl>								# <- Naming a second graph

WHERE {
	{ ?s ?p ?o }										# <- Querying the defaulkt graph
	UNION
	{ GRAPH ?g { ?s ?p ?o } }							# <- Querying all named graph because we use a variable ?g instead of a specific name
}

-----------------------------------------------------
# -> Query 1 specific named graph

PREFIX dc: <http://purl.org/dc/elements/1.1/>
PREFIX : <.>

SELECT ?title
FROM       <ds-dft.ttl>									# <- The default graph
FROM NAMED <ds-ng-1.ttl>								# <- Named but unsued
FROM NAMED <ds-ng-2.ttl>

WHERE {
	GRAPH :ds-ng-2.ttl { ?b dc:title ?title }			# <- Specify on which graph the pattern will be applied, using the graph's name (which is an URI)
}

-----------------------------------------------------